1. 数据规模: 想要在1s之内解决问题
O(n^2)的算法可以处理大约10^4级别的数据
O(n)的算法可以处理大约10^8级别的数据
O(nlogn)的算法可以处理大约10^7级别的数据

2. 链表相关
1): 注意dummyHead的定义可以使你统一对头节点的操作，减少了
对头节点时删除逻辑的判断，降低了程序出现bug的概率。
2): dummyHead的next不要忘记指向头节点
3): 不要忘记设置头节点

3. 二维数组相关
int[y][x] -> y轴 row -> x轴 column
利用设定偏移量数组来遍历访问二维数组坐标周围的数
int[][] offset = new int[][]{{-1,0},{0,1},{1,0},{0,-1}}; 

4. Array数组可以实现栈以及队列
//栈先进后出
当Array作为栈时, push从数组尾部添加元素O(1)，从数组尾部去除元素O(1)
//队列先进先出
当Array作为队列时, enqueue从数组尾部添加元素, 从数组头部去除元素O(n) -> 可以使用循环数组优化

5. 队列的典型应用 -> 层序遍历 -> 先进先出 -> 层数较浅的元素先进队列所以先出队列

6. 队列在Java中的实现 LinkedList -> enqueue = poll -> dequeue = offer -> enqueue 

7. 队列也可用来作为图的广度优先遍历

8. 递归: 可以分解为相同子问题的问题 -> 二叉树具有天然递归结构

9. 根节点 -> 具有左子树或右子树 叶子节点 -> 左子树与右子树均为空

10. 利用正向思维思考回溯

11. 利用布尔数组来标记访问/未访问的值

12. java中的队列由链表来实现: LinkedList implements Queue
实用方法: offer() -> enqueue() : poll() -> dequeue() : addFirst()

13. 动态规划的空间优化: 因为动态规划只依赖上一次状态, 可以不需要记录
所有的状态。O(2*C) - > O(C)

14. 因01背包问题的dp仅依赖于之前的状态可以利用从后往前遍历
构建空间复杂度为O(C)的dp table

15. 在解决二分查找问题的时候要先画清楚区间

16. 异或的性质 任何数异或它自己为0 -> A异或0等于A

17. 重写Comparator, compare方法 -> o1 - o2 数字升序 -> o2 - o1 数字降序

18. 二分法不死循环的技巧 while循环条件 -> start + 1 < end: 当start与end相邻时即
退出循环

19. 二分法的理解 -> 去除解不存在的部分, 保留解存在的部分

20. 中序遍历二分搜索树 -> 从小到大按序输出 

21. 线段树的业务应用场景
实质: 基于区间的统计查询
例: 2017年注册用户中消费最高的用户? 消费最少的用户?
学习时间最长的用户?
某一个太空区间中天体总量?